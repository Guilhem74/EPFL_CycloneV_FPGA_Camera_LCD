library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
 
Entity Master_Interface is
Port(
 Clk : IN STD_LOGIC ;
 Reset_n : IN STD_LOGIC ;
 Address: IN STD_LOGIC_VECTOR(31 downto 0) ;
 Length_Frame: IN STD_LOGIC_VECTOR(31 downto 0) ;
 Ready: IN STD_LOGIC ;
 --FIFO Connection
 FIFO_Data_Available: IN STD_LOGIC ;
 FIFO_Read_Request : OUT STD_LOGIC ;
 FIFO_Read_Data : IN STD_LOGIC_VECTOR(31 downto 0) ; 
-- Avalon Master :
 AM_readdatavalid: IN STD_LOGIC;
 AM_Adresse : OUT STD_LOGIC_VECTOR(31 downto 0) ;
 AM_ByteEnable : OUT STD_LOGIC_VECTOR(3 downto 0) ;
 AM_Write : OUT STD_LOGIC ;
 AM_Read : OUT STD_LOGIC ;
 AM_DataWrite : OUT STD_LOGIC_VECTOR(31 downto 0) ;
 AM_BurstCount : OUT STD_LOGIC_VECTOR(3 downto 0) ;
 AM_DataRead : IN STD_LOGIC_VECTOR(31 downto 0) ;
 AM_WaitRequest : IN STD_LOGIC
) ; 
end entity Master_Interface;

Architecture Comp of Master_Interface is
	signal Current_Address, Offset_Address: STD_LOGIC_VECTOR(31 downto 0);
	signal Copy_Base_Address,Copy_Length_Frame: STD_LOGIC_VECTOR(31 downto 0);
	TYPE Master_State IS (Idle, Ask_Data_FIFO,Collect_Data_FIFO, Loop_DMA);
	signal State:Master_State;
	signal Actual_Value_indice_FIFO: unsigned(4 downto 0):="00000";
	type DATA is array (7 downto 0) of STD_LOGIC_VECTOR(31 downto 0);
	signal DATA_Array: Data;
	signal Init_Transfer : std_logic;	
Begin 
	
	-- Acquisition
	Avalon_Bus:
	Process(Clk, Reset_n)

	variable Actual_Value_indice_DMA: unsigned(4 downto 0):="00000";
		Begin
		 if Reset_n = '0' then
			 AM_Write <= '0';
			 AM_Read <= '0';
			 AM_ByteEnable <= "0000";
			 FIFO_Read_Request <='0';
 			 AM_Adresse <=(others =>'0');
 			 AM_ByteEnable <=(others =>'0');
			 AM_Write <='0';
 			 AM_Read <='0';
 			 AM_DataWrite <=(others =>'0');
 			 AM_BurstCount<=(others =>'0');
 			DATA_Array<=(others=>(others=>'0'));
 			Actual_Value_indice_FIFO<=(others => '0');
			Actual_Value_indice_DMA:=(others => '0');
			Current_Address<=(others => '0');
			Offset_Address<=(others => '0');
			Copy_Length_Frame<=(others => '0');
			Init_Transfer<='0';
		 elsif rising_edge(Clk) then
			case State is
				when IDLE => 	
					Actual_Value_indice_FIFO<=(others => '0');
					Actual_Value_indice_DMA:=(others => '0');
					Offset_Address<=(others => '0');
					AM_Write<='0';
					if Ready='1'then
						Copy_Base_Address<=Address;
						Copy_Length_Frame<=Length_Frame;
						State<=Ask_Data_FIFO;
						
					end if;
				when Ask_Data_FIFO =>
					AM_Write<='0';
					if Offset_Address<std_logic_vector(unsigned(Copy_Length_Frame)) then
						Current_Address<=std_logic_vector(unsigned(Copy_Base_Address)+ unsigned(Offset_Address));
						if FIFO_Data_Available = '0' then
							-- Read Number_Of_Transfert data
							FIFO_Read_Request<='1';
							State<=Collect_Data_FIFO;
							Actual_Value_indice_FIFO<=(others => '0');
							Actual_Value_indice_DMA:=(others => '0');
						end if;
					else
						State<=IDLE;
					end if;
				when  Collect_Data_FIFO =>
					AM_Write<='0';
					if Actual_Value_indice_FIFO< 7 then
						
						FIFO_Read_Request<='1';
						
					else
						State<=Loop_DMA;
						FIFO_Read_Request<='0';
					end if;
					DATA_Array(to_integer(Actual_Value_indice_FIFO))<=FIFO_Read_Data;
					Actual_Value_indice_FIFO<=Actual_Value_indice_FIFO+1;
				when Loop_DMA =>
					if AM_WaitRequest='0' and Init_Transfer='1' then--Write available	
						Actual_Value_indice_DMA:=Actual_Value_indice_DMA+1;
					end if;
					AM_Write<='1';
					AM_Adresse<=Current_Address;-- Burst write, address is always the same
					AM_BurstCount<=std_logic_vector(to_unsigned(8,4));
					AM_DataWrite<=DATA_Array(to_integer(Actual_Value_indice_DMA));
					AM_ByteEnable<="1111";
					Init_Transfer<='1';
					
					if Actual_Value_indice_DMA<7 then -- Burst count finish
						AM_Write<='1';
					else
						AM_Write<='0';--Last write
						Offset_Address<=std_logic_vector(unsigned(Offset_Address)+to_unsigned(8,32));
						State <= Ask_Data_FIFO;
						Init_Transfer<='0';
						
					end if;
					
			end case;	
		 end if;
	End Process Avalon_Bus;

End Comp; 