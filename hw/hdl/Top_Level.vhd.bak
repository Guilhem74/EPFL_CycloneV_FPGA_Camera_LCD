library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
 

Entity Top_Level is
Port(
	 Clk_FPGA : IN STD_LOGIC ;
	 Reset_n : IN STD_LOGIC ;
	 -- Avalon Bus :
	 AM_Adresse : OUT STD_LOGIC_VECTOR(31 DOWNTO 0);
	 AM_BurstCount : OUT STD_LOGIC_VECTOR(3 DOWNTO 0);
	 AM_ByteEnable : OUT STD_LOGIC_VECTOR(3 DOWNTO 0);
	 AM_DataRead : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
	 AM_DataWrite : OUT STD_LOGIC_VECTOR(31 DOWNTO 0);
	 AM_Read : OUT STD_LOGIC;
	 AM_WaitRequest : IN STD_LOGIC;
	 AM_Write : OUT STD_LOGIC;
	--Camera I/O
	 Clk_Camera: STD_LOGIC;
	 FVAL : IN STD_LOGIC;
	 LVAL : IN STD_LOGIC ;
	 Data_Camera : IN STD_LOGIC_VECTOR(11 downto 0) 
	 
) ; 
end entity Top_Level;
Architecture Comp of Top_Level is
SIGNAL Address : STD_LOGIC_VECTOR(31 DOWNTO 0);
SIGNAL FIFO_Data_Available : STD_LOGIC;
SIGNAL FIFO_Read_Data : STD_LOGIC_VECTOR(31 DOWNTO 0);
SIGNAL FIFO_Master_Interface_Read_Request : STD_LOGIC;
SIGNAL Ready : STD_LOGIC;
SIGNAL data_sig : STD_LOGIC_VECTOR(31 DOWNTO 0);
SIGNAL FIFO_Master_Interface_Write_Request : STD_LOGIC;
SIGNAL almost_full_sig : STD_LOGIC;
SIGNAL empty_sig : STD_LOGIC;
SIGNAL full_sig : STD_LOGIC;
SIGNAL usedw_sig : STD_LOGIC_VECTOR (4 DOWNTO 0);
SIGNAL Out_Pixel:  STD_LOGIC_VECTOR(15 downto 0) ;
SIGNAL Pixel_Valid_Out:  STD_LOGIC;
SIGNAL Reset_H: STD_LOGIC;
		COMPONENT Master_Interface
			PORT (
			Address : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
			AM_Adresse : OUT STD_LOGIC_VECTOR(31 DOWNTO 0);
			AM_BurstCount : OUT STD_LOGIC_VECTOR(3 DOWNTO 0);
			AM_ByteEnable : OUT STD_LOGIC_VECTOR(3 DOWNTO 0);
			AM_DataRead : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
			AM_DataWrite : OUT STD_LOGIC_VECTOR(31 DOWNTO 0);
			AM_Read : OUT STD_LOGIC;
			AM_WaitRequest : IN STD_LOGIC;
			AM_Write : OUT STD_LOGIC;
			Clk : IN STD_LOGIC;
			FIFO_Data_Available : IN STD_LOGIC;
			FIFO_Read_Data : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
			FIFO_Read_Request : OUT STD_LOGIC;
			Ready : IN STD_LOGIC;
			Reset_n : IN STD_LOGIC
			);
		END COMPONENT;
		COMPONENT FIFO_1 IS-- Fifo feeding the master interface
		PORT
		(
			aclr		: IN STD_LOGIC ;
			clock		: IN STD_LOGIC ;
			data		: IN STD_LOGIC_VECTOR (31 DOWNTO 0);
			rdreq		: IN STD_LOGIC ;
			wrreq		: IN STD_LOGIC ;
			almost_empty		: OUT STD_LOGIC ;
			almost_full		: OUT STD_LOGIC ;
			empty		: OUT STD_LOGIC ;
			full		: OUT STD_LOGIC ;
			q		: OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
			usedw		: OUT STD_LOGIC_VECTOR (4 DOWNTO 0)
		);
		END COMPONENT FIFO_1;
		COMPONENT Acquisition_module-- Interface capturing the data coming from the camera
		PORT (
		Clk : IN STD_LOGIC;
		Data_Camera : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
		FVAL : IN STD_LOGIC;
		LVAL : IN STD_LOGIC;
		Out_Pixel : OUT STD_LOGIC_VECTOR(15 DOWNTO 0);
		Reset_n : IN STD_LOGIC;
		Pixel_Valid_Out: OUT STD_LOGIC
		);
		END COMPONENT;
		signal aclr_FIFO_Inter_Clock_Domain		:  STD_LOGIC  := '0';
		signal	data_FIFO_Inter_Clock_Domain		:  STD_LOGIC_VECTOR (15 DOWNTO 0);
		signal	rdclk_FIFO_Inter_Clock_Domain		:  STD_LOGIC ;
		signal	rdreq_FIFO_Inter_Clock_Domain		:  STD_LOGIC ;
		signal	wrclk_FIFO_Inter_Clock_Domain		:  STD_LOGIC ;
		signal	wrreq_FIFO_Inter_Clock_Domain	:  STD_LOGIC ;
		signal	Output_Camera_2Pixels_32Bits		:  STD_LOGIC_VECTOR (31 DOWNTO 0);
		signal	rdempty_FIFO_Inter_Clock_Domain		:  STD_LOGIC ;
		signal	wrfull_FIFO_Inter_Clock_Domain		:  STD_LOGIC ;
		component FIFO_Inter_Clock_Domain--Fifo doing the cross domain, feeded by the camera interface and feed the master avalon interface
		PORT
		(
			aclr		: IN STD_LOGIC  := '0';
			data		: IN STD_LOGIC_VECTOR (15 DOWNTO 0);
			rdclk		: IN STD_LOGIC ;
			rdreq		: IN STD_LOGIC ;
			wrclk		: IN STD_LOGIC ;
			wrreq		: IN STD_LOGIC ;
			q		: OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
			rdempty		: OUT STD_LOGIC ;
			wrfull		: OUT STD_LOGIC 
		);
		end component;

BEGIN
Reset_H<= not(Reset_n);
		
			Master_Interface_inst : Master_Interface
			PORT MAP (
		-- list connections between master ports and signals
			Address => Address,
			AM_Adresse => AM_Adresse,
			AM_BurstCount => AM_BurstCount,
			AM_ByteEnable => AM_ByteEnable,
			AM_DataRead => AM_DataRead,
			AM_DataWrite => AM_DataWrite,
			AM_Read => AM_Read,
			AM_WaitRequest => AM_WaitRequest,
			AM_Write => AM_Write,
			Clk => Clk_FPGA,
			FIFO_Data_Available => FIFO_Data_Available,
			FIFO_Read_Data => FIFO_Read_Data,
			FIFO_Read_Request => FIFO_Master_Interface_Read_Request,
			Ready => Ready,
			Reset_n => Reset_n
			);
			FIFO_1_inst : FIFO_1 PORT MAP (
				aclr	 => Reset_H,
				clock	 => Clk_FPGA,
				data	 => Output_Camera_2Pixels_32Bits,
				rdreq	 => FIFO_Master_Interface_Read_Request,
				wrreq	 => FIFO_Master_Interface_Write_Request,
				almost_empty	 => FIFO_Data_Available,
				almost_full	 => almost_full_sig,
				empty	 => empty_sig,
				full	 => full_sig,
				q	 => FIFO_Read_Data,
				usedw	 => usedw_sig
			);
			Acquisition_module_inst : Acquisition_module
			PORT MAP (
			Clk => Clk_Camera,
			Data_Camera => Data_Camera,
			FVAL => FVAL,
			LVAL => LVAL,
			Out_Pixel => Out_Pixel,
			Reset_n => Reset_n,
			Pixel_Valid_Out=> Pixel_Valid_Out
			);
			FIFO_Inter_Clock_Domain_inst : FIFO_Inter_Clock_Domain
			PORT MAP
			(
				aclr		=>Reset_H,
				data		=>Out_Pixel,
				rdclk		=>Clk_FPGA,
				rdreq		=>rdreq_FIFO_Inter_Clock_Domain,
				wrclk		=>Clk_Camera,
				wrreq		=>Pixel_Valid_Out,
				q		=>Output_Camera_2Pixels_32Bits,
				rdempty		=>rdempty_FIFO_Inter_Clock_Domain,
				wrfull		=> wrfull_FIFO_Inter_Clock_Domain
			);
			
	Transfert_Fifo:Process(Clk_FPGA, Reset_n)
		begin
		if Reset_n = '0' then
			rdreq_FIFO_Inter_Clock_Domain<='0';
			FIFO_Master_Interface_Write_Request<='0';
		elsif rising_edge(Clk_FPGA) then
			if(rdempty_FIFO_Inter_Clock_Domain='0') then
				rdreq_FIFO_Inter_Clock_Domain<='1';
				FIFO_Master_Interface_Write_Request<='1';
			else
				rdreq_FIFO_Inter_Clock_Domain<='0';
				FIFO_Master_Interface_Write_Request<='0';
			end if;
		end if;
	End Process Transfert_Fifo;

End Comp; 